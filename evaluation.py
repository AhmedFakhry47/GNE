import numpy as np
import math
import multiprocessing
import scipy

from sklearn.metrics import average_precision_score, roc_auc_score
from sklearn.metrics.pairwise import euclidean_distances
from sklearn.metrics.pairwise import cosine_similarity
from joblib import Parallel, delayed


# Calculate distnace between embedding vectors
def calculate_distance( embeddings, type): # N * emb_size
    if type == 'euclidean_distances':
        Y_predict = -1.0 * euclidean_distances(embeddings, embeddings)
        return Y_predict
    if type == 'cosine_similarity':
        Y_predict = cosine_similarity(embeddings, embeddings)
        return Y_predict

# Calculate the norm of a vector
def norm(a):
    sum = 0.0
    for i in range(len(a)):
        sum = sum + a[i] * a[i]
    return math.sqrt(sum)

# Cosine similarity between two vectors
def cosine_sim( a,  b):
    sum = 0.0
    for i in range(len(a)):
        sum = sum + a[i] * b[i]
    if (norm(a) * norm(b) ==0):
        return 0
    return sum/(norm(a) * norm(b))

# Evaluate ROC on test data (list format)
def evaluate_ROC(X_test, Embeddings):
    num_cores = multiprocessing.cpu_count()
    y_true = [ X_test[i][2] for i in range(len(X_test))]
    y_predict = Parallel(n_jobs=num_cores)(delayed(cosine_sim)(Embeddings[X_test[i][0],:], Embeddings[X_test[i][1], :])  for i in range(len(X_test)))
    roc = roc_auc_score(y_true, y_predict)
    if roc < 0.5:
        roc = 1 - roc
    pr = average_precision_score(y_true, y_predict)
    return roc, pr

# Evaluate ROC using predicted cosine matrix 
def evaluate_ROC_from_matrix(X_edges, y_true, matrix):
    y_predict = [matrix[int(edge[0]), int(edge[1])]  for edge in X_edges]
    roc = roc_auc_score(y_true, y_predict)
    if roc < 0.5:
        roc = 1 - roc
    pr = average_precision_score(y_true, y_predict)
    return roc, pr

# Evaluate ROC based on euclidean
def evaluate_ROC_euclidean(X_test, Embeddings):
    y_true = [ X_test[i][2] for i in range(len(X_test))]
    y_predict = [ -1.0 * scipy.spatial.distance.euclidean(Embeddings[X_test[i][0],:], Embeddings[X_test[i][1], :]) for i in range(len(X_test))]
    roc = roc_auc_score(y_true, y_predict)
    if roc < 0.5:
        roc = 1 - roc
    return roc

# Load the embedding generated by other methods:LINE, Node2vec
def load_embedding(embedding_file, N, combineAttribute=False, datafile=None):
    f = open(embedding_file)
    i = 0
    line = f.readline()
    line = line.strip().split(' ')
    d = int(line[1])
    embeddings = np.random.randn(int(N), d)
    line = f.readline()
    while line:
        line = line.strip().split(' ')
        embeddings[int(line[0]),:] = line[1:]
        i = i + 1
        line = f.readline()
    f.close()
    if combineAttribute:
        data = load_datafile(datafile, N)
        # print(data.shape)
        temp = np.hstack((embeddings, data))
        # print(temp.shape)
        embeddings = temp
    return embeddings

# Load the expression data
def load_datafile(data_file, N):
    f = open(data_file)
    i = 0
    line = f.readline()
    line = line.strip().split(' ')
    d = len(line[1:])
    data = np.zeros([int(N), d])
    while line:
        # print(i)
        data[int(line[0]),:] = line[1:]
        i = i + 1
        line = f.readline()
        if i < N:
            line = line.strip().split(' ')
        else:
            break
    f.close()
    return data

# Read the test links to create a list 
def read_test_link(testlinkfile):
    X_test = []
    f = open(testlinkfile)
    line = f.readline()
    while line:
        line = line.strip().split(' ')
        X_test.append([int(line[0]), int(line[1]), int(line[2])])
        line = f.readline()
    f.close()
    return X_test


def get_edge_embeddings(Embeddings, edge_list):
        embs = []
        for edge in edge_list:
            node1 = int(edge[0])
            node2 = int(edge[1])
            emb1 = Embeddings[node1]
            emb2 = Embeddings[node2]
            edge_emb = np.multiply(emb1, emb2)
            embs.append(edge_emb)
        embs = np.array(embs)
        return embs

def evaluationClassifier(pos_edges, neg_edges):
    from sklearn.linear_model import LogisticRegression

    pos_val_edge_embs = get_edge_embeddings(pos_edges)
    neg_val_edge_embs = get_edge_embeddings(neg_edges)
    val_edge_embs = np.concatenate([pos_val_edge_embs, neg_val_edge_embs])
    val_edge_labels = np.concatenate([np.ones(len(pos_edges)), np.zeros(len(neg_edges))])

    edge_classifier = LogisticRegression(random_state=0)
    edge_classifier.fit(val_edge_embs, val_edge_labels)